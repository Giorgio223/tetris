<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>8×8 Blocks</title>
  <style>
    :root{
      --bg1:#3f5da8;
      --bg2:#3a579e;

      --cell:#1b2b52;
      --cell2:#182747;

      --text:#ffffff;
      --yellow:#ffcf3f;

      --wrapW: min(560px, 96vw);

      /* tight seams */
      --cellSize: clamp(24px, 6.05vw, 34px);
      --gap: 1px;

      /* tray blocks closer */
      --trayB: 16px;
      --trayGap: 2px;

      --ghostB: 24px;
      --ghostGap: 4px;

      /* LOWER the lifted ghost a bit (was 86px) */
      --ghostOffX: 20px;
      --ghostOffY: 66px;

      --shadow: 0 18px 40px rgba(0,0,0,.28);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background: linear-gradient(180deg, var(--bg1) 0%, var(--bg2) 100%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;
      color:var(--text);
      user-select:none;
      -webkit-user-select:none;
      touch-action:none;
      overflow:hidden;
    }

    .wrap{
      width:var(--wrapW);
      display:flex;
      flex-direction:column;
      gap:10px;
      padding: 14px 0;
    }

    /* top */
    .top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 6px 6px;
      gap:10px;
    }
    .leftScore{
      display:flex;
      align-items:baseline;
      gap:10px;
    }
    .scoreBig{
      font-weight: 1000;
      font-size: 44px;
      line-height: 1;
      letter-spacing: .5px;
      text-shadow: 0 3px 0 rgba(0,0,0,.18);
      font-variant-numeric: tabular-nums;
    }
    .best{
      display:flex;
      align-items:center;
      gap:10px;
      font-weight: 1000;
      font-size: 34px;
      color: var(--yellow);
      text-shadow: 0 3px 0 rgba(0,0,0,.18);
      font-variant-numeric: tabular-nums;
    }
    .crown{
      width:44px;height:44px;
      filter: drop-shadow(0 3px 0 rgba(0,0,0,.18));
    }

    /* New Game moved to side (top right area) */
    .sideBtn{
      display:flex;
      align-items:center;
      gap:10px;
    }
    button{
      background: rgba(0,0,0,.14);
      color:#fff;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 999px;
      padding: 10px 14px;
      font-weight: 950;
      cursor:pointer;
      box-shadow: 0 6px 0 rgba(0,0,0,.14);
      white-space:nowrap;
    }
    button:active{transform: translateY(1px); box-shadow: 0 5px 0 rgba(0,0,0,.14)}


    .bottomBar{
      display:flex;
      justify-content:center;
      padding: 6px 6px 2px;
    }
    .bottomBar button{
      padding: 12px 18px;
      font-size: 16px;
    }

    .balanceBox{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:4px;
      margin-right: 6px;
      min-width: 160px;
    }
    .balanceLabel{
      font-weight: 950;
      font-size: 12px;
      opacity:.92;
      letter-spacing:.3px;
    }
    .balanceValue{
      font-weight: 1000;
      font-size: 18px;
      color: var(--yellow);
      font-variant-numeric: tabular-nums;
      text-shadow: 0 2px 0 rgba(0,0,0,.18);
    }
    .balanceAddr{
      font-size: 11px;
      opacity:.78;
      max-width: 220px;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    /* TonConnect UI button container */
    .tonBtn{
      display:flex;
      justify-content:flex-end;
    }


    .boardShell{
      background: rgba(20,30,58,.22);
      padding: 10px;
      border-radius: 22px;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.06), var(--shadow);
    }
    .board{
      background: linear-gradient(180deg, #22356a 0%, #1c2c58 100%);
      border-radius: 18px;
      padding: 10px;
      box-shadow: inset 0 0 0 3px rgba(0,0,0,.18);
    }
    .grid{
      display:grid;
      grid-template-columns: repeat(8, var(--cellSize));
      grid-template-rows: repeat(8, var(--cellSize));
      gap: var(--gap);
      justify-content:center;
      background: rgba(0,0,0,.16);
      padding: var(--gap);
      border-radius: 14px;
    }

    .cell{
      position:relative;
      border-radius: 7px;
      background: linear-gradient(180deg, var(--cell) 0%, var(--cell2) 100%);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.035);
      overflow:hidden;
    }

    /* Smart highlight (подсветка) */
    .cell.hintPlace{
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,.22),
        0 0 0 2px rgba(255,255,255,.06);
    }
    .cell.hintLine{
      box-shadow:
        inset 0 0 0 2px rgba(255,207,63,.35),
        0 0 18px rgba(255,207,63,.14);
      animation: hintPulse .6s ease-in-out infinite alternate;
    }
    @keyframes hintPulse{
      from{ filter: brightness(1); }
      to{ filter: brightness(1.12); }
    }

    .tile, .ptile{
      position:absolute;
      inset: -2px;
      border-radius: 7px;
      background: var(--fill, #ff6b6b);
      box-shadow:
        inset 0 2px 0 rgba(255,255,255,.22),
        inset 0 -3px 0 rgba(0,0,0,.22),
        inset 3px 0 0 rgba(255,255,255,.14),
        inset -3px 0 0 rgba(0,0,0,.18),
        0 3px 0 rgba(0,0,0,.10);
    }
    .tile::before, .ptile::before{
      content:"";
      position:absolute;
      inset: 16% 16% 42% 16%;
      border-radius: 6px;
      background: rgba(255,255,255,.14);
    }
    .tile::after, .ptile::after{
      content:"";
      position:absolute;
      inset: 10%;
      border-radius: 7px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.10);
    }

    .ptile{
      opacity: .48;
      filter: saturate(1.08);
      box-shadow:
        inset 0 2px 0 rgba(255,255,255,.18),
        inset 0 -3px 0 rgba(0,0,0,.18),
        inset 3px 0 0 rgba(255,255,255,.10),
        inset -3px 0 0 rgba(0,0,0,.14);
    }

    .tray{
      display:flex;
      justify-content:space-between;
      gap:14px;
      padding-top: 6px;
    }
    .piece{
      flex:1;
      min-width:0;
      display:grid;
      place-items:center;
      padding: 10px 6px;
      border-radius: 14px;
      background: rgba(10,16,32,.12);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.06);
      cursor:grab;
      transition: transform .08s ease, filter .08s ease, opacity .15s ease;
    }
    .piece:active{cursor:grabbing}
    .piece.isDragging{
      filter: saturate(1.05);
      transform: translateY(-6px);
    }
    .piece.disabled{
      opacity:.55;
    }

    .pieceInner{
      --b: var(--trayB);
      --g: var(--trayGap);
      display:grid;
      gap: var(--g);
      grid-template-columns: repeat(5, var(--b));
      grid-template-rows: repeat(5, var(--b));
      width: calc(5*var(--b) + 4*var(--g));
      height: calc(5*var(--b) + 4*var(--g));
    }

    .pblock{
      width:var(--b); height:var(--b);
      border-radius: 6px;
      background: var(--pcolor, #ff6b6b);
      box-shadow:
        inset 0 2px 0 rgba(255,255,255,.22),
        inset 0 -3px 0 rgba(0,0,0,.20),
        inset 3px 0 0 rgba(255,255,255,.14),
        inset -3px 0 0 rgba(0,0,0,.18),
        0 2px 0 rgba(0,0,0,.10);
      position:relative;
    }
    .pblock::before{
      content:"";
      position:absolute;
      inset: 18% 18% 44% 18%;
      border-radius: 5px;
      background: rgba(255,255,255,.16);
    }
    .pblock.empty{
      background: transparent;
      box-shadow:none;
    }
    .pblock.empty::before{display:none}

    .dragGhost{
      position:fixed;
      left:0; top:0;
      transform: translate(-9999px,-9999px);
      z-index:9999;
      pointer-events:none;
      opacity:.98;
      will-change: transform;
      filter: drop-shadow(0 14px 26px rgba(0,0,0,.35));
    }

    /* Drag ghost: crisp block + smaller shadow like in screenshot */
    .dragGhost .pblock{
      position: relative;
      z-index: 1;
    }
    .dragGhost .pblock.gblock::after{
      content:"";
      position:absolute;
      inset: 3px;
      border-radius: 6px;
      background: rgba(0,0,0,.28);
      transform: translate(-8px,-8px) scale(0.86);
      z-index: -1;
      box-shadow: 0 2px 0 rgba(0,0,0,.12);
    }

    .dragGhost .pieceInner{
      --b: var(--ghostB);
      --g: var(--ghostGap);
    }

    .toast{
      position:fixed;
      bottom:16px;
      left:50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.16);
      color:#fff;
      padding:10px 14px;
      border-radius: 999px;
      font-weight:950;
      font-size:13px;
      opacity:0;
      transition: opacity .18s ease;
      pointer-events:none;
    }
    .toast.show{opacity:1}

    /* Game Over overlay */
    .overlay{
      position:fixed;
      inset:0;
      display:none;
      place-items:center;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(3px);
      z-index: 10000;
    }
    .overlay.show{display:grid}
    .modal{
      width: min(420px, 90vw);
      background: rgba(20,28,54,.92);
      border:1px solid rgba(255,255,255,.16);
      border-radius: 22px;
      box-shadow: 0 22px 60px rgba(0,0,0,.35);
      padding: 18px 16px 14px;
      text-align:center;
    }
    .modal h2{
      margin:6px 0 8px;
      font-size: 28px;
      letter-spacing:.6px;
    }
    .modal p{
      margin:0 0 14px;
      color: rgba(255,255,255,.85);
      font-weight:800;
    }
    .modal .row{
      display:flex;
      gap:10px;
      justify-content:center;
      margin-top: 10px;
      flex-wrap:wrap;
    }
    .modal .btnSecondary{
      background: rgba(255,255,255,.08);
    }
  </style>

  <!-- TON Connect UI (vanilla) -->
  <script src="https://cdn.jsdelivr.net/npm/@tonconnect/ui@2.3.1/dist/tonconnect-ui.min.js"></script>

</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="leftScore">
        <div class="scoreBig" id="score">0</div>
      </div>

      <div class="sideBtn">
        
        <div class="balanceBox" title="TON кошелек и баланс">
          <span class="balanceLabel">Баланс:</span>
          <span class="balanceValue" id="tonBalance">—</span>
          <span class="balanceAddr" id="tonAddr"></span>
          <div class="tonBtn" id="tonconnect-button"></div>
        </div>
<div class="best" title="Лучший результат">
          <svg class="crown" viewBox="0 0 64 64" aria-hidden="true">
            <path d="M10 22l10 10 12-18 12 18 10-10 6 28H4l6-28z" fill="#ffcf3f"/>
            <path d="M12 46h40v6H12z" fill="#e6b92f"/>
            <circle cx="20" cy="26" r="4" fill="#ffe37a"/>
            <circle cx="32" cy="18" r="4" fill="#ffe37a"/>
            <circle cx="44" cy="26" r="4" fill="#ffe37a"/>
          </svg>
          <span id="bestScore">0</span>
        </div>
        
      </div>
    </div>

    <div class="boardShell">
      <div class="board">
        <div class="grid" id="grid"></div>
      </div>
    </div>
    <div class="tray" id="tray"></div>

    <div class="bottomBar">
      <button id="newGameBtnBottom">Новая игра</button>
    </div>

</div>

  <div class="dragGhost" id="ghost"></div>
  <div class="toast" id="toast"></div>

  <div class="overlay" id="overlay">
    <div class="modal">
      <h2 id="modalTitle">GAME OVER</h2>
      <p id="modalText">Ходов больше нет.</p>
      <div class="row" id="modalRow">
        <button id="modalPrimary">Новая игра</button>
        <button class="btnSecondary" id="modalSecondary">Отмена</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const N = 8;
  const gridEl = document.getElementById('grid');
  const trayEl = document.getElementById('tray');
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('bestScore');
  const ghostEl = document.getElementById('ghost');
  const toastEl = document.getElementById('toast');
    const newGameBtn = document.getElementById('newGameBtnBottom');

  const tonBalanceEl = document.getElementById('tonBalance');
  const tonAddrEl = document.getElementById('tonAddr');


  const overlay = document.getElementById('overlay');
  const modalTitle = document.getElementById('modalTitle');
  const modalText  = document.getElementById('modalText');
  const modalPrimary = document.getElementById('modalPrimary');
  const modalSecondary = document.getElementById('modalSecondary');

  let board = Array.from({length:N}, () => Array(N).fill(null));
  let score = 0;
  let best = Number(localStorage.getItem('bb_best') || 0);

  let comboStreak = 0;
  let isGameOver = false;

  const COLORS = ["#ff4d4d","#ffcf3f","#3fe36b","#4d7dff","#c85cff","#ff62d4"];
  const SHAPES = [
    [[0,0]],
    [[0,0],[1,0]],
    [[0,0],[1,0],[2,0]],
    [[0,0],[0,1],[0,2]],
    [[0,0],[1,0],[0,1],[1,1]],
    [[0,0],[1,0],[2,0],[3,0]],
    [[0,0],[0,1],[1,1]],
    [[1,0],[1,1],[0,1]],
    [[0,0],[1,0],[2,0],[1,1]],
    [[0,0],[0,1],[0,2],[1,2]],
    [[1,0],[1,1],[1,2],[0,2]],
    [[0,0],[1,0],[2,0],[3,0],[4,0]],
    [[0,0],[0,1],[1,1],[1,2]],
    [[1,0],[1,1],[0,1],[0,2]],
    [[0,0],[1,0],[2,0],[0,1],[1,1],[2,1]],
    [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2]],
  ];

  let tray = [];
  let drag = null;

  let rafPending = false;
  let lastX = 0, lastY = 0;


  function getCellFromClientXY(clientX, clientY){
    const rect = gridEl.getBoundingClientRect();
    if(clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) return null;

    const firstCell = gridEl.children[0];
    if(!firstCell) return null;
    const cellRect = firstCell.getBoundingClientRect();
    const gridStyle = getComputedStyle(gridEl);
    const gap = parseFloat(gridStyle.gap || gridStyle.columnGap || "0") || 0;

    const stepX = cellRect.width + gap;
    const stepY = cellRect.height + gap;

    // position inside grid (relative)
    const rx = clientX - rect.left;
    const ry = clientY - rect.top;

    const gx = Math.floor(rx / stepX);
    const gy = Math.floor(ry / stepY);

    if(gx < 0 || gx >= N || gy < 0 || gy >= N) return null;

    return { gx, gy, cellRect, rect, gap };
  }

  function snapGhostToCell(gx, gy){
    const cell = gridEl.children[gy*N + gx];
    const r = cell.getBoundingClientRect();
    const x = r.left + r.width/2;
    const y = r.top + r.height/2 - 22; // a bit higher than finger
    ghostEl.style.transform = `translate(${x}px, ${y}px) translate(-50%, -50%)`;
  }


  function setScore(v){
    score = v;
    scoreEl.textContent = String(score);
    if(score > best){
      best = score;
      bestEl.textContent = String(best);
      localStorage.setItem('bb_best', String(best));
    }
  }

  function showToast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toastEl.classList.remove('show'), 900);
  }

  function openModal(type){
    // type: 'gameover' | 'confirm'
    overlay.classList.add('show');
    if(type === 'gameover'){
      modalTitle.textContent = "GAME OVER";
      modalText.textContent = "Ходов больше нет.";
      modalSecondary.style.display = "none";
    } else {
      modalTitle.textContent = "Новая игра?";
      modalText.textContent = "Вы уверены начать новую игру?";
      modalSecondary.style.display = "";
    }
  }
  function closeModal(){
    overlay.classList.remove('show');
  }

  function buildGrid(){
    gridEl.innerHTML = "";
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const c = document.createElement('div');
        c.className = "cell";
        c.dataset.x = x;
        c.dataset.y = y;
        gridEl.appendChild(c);
      }
    }
  }

  function renderBoard(){
    const cells = gridEl.children;
    let i = 0;
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const el = cells[i++];
        const col = board[y][x];
        el.querySelectorAll('.tile').forEach(n => n.remove());
        if(col){
          const t = document.createElement('div');
          t.className = "tile";
          t.style.setProperty('--fill', col);
          el.appendChild(t);
        }
      }
    }
  }

  function cryptoRandomId(){
    if(window.crypto?.getRandomValues){
      const a = new Uint32Array(1);
      window.crypto.getRandomValues(a);
      return "p" + a[0].toString(16);
    }
    return "p" + Math.random().toString(16).slice(2);
  }

  function randomPiece(){
    const shape = SHAPES[(Math.random()*SHAPES.length)|0];
    const color = COLORS[(Math.random()*COLORS.length)|0];
    return { shape, color, id: cryptoRandomId() };
  }

  function renderPieceInner(p, mode /* tray|ghost */){
    const inner = document.createElement('div');
    inner.className = "pieceInner";
    inner.style.setProperty('--pcolor', p.color);

    const coords = p.shape;
    const xs = coords.map(c=>c[0]), ys = coords.map(c=>c[1]);
    const minX = Math.min(...xs), minY = Math.min(...ys);
    const norm = coords.map(([x,y]) => [x-minX, y-minY]);
    const w = Math.max(...norm.map(c=>c[0])) + 1;
    const h = Math.max(...norm.map(c=>c[1])) + 1;
    const offX = Math.floor((5 - w)/2);
    const offY = Math.floor((5 - h)/2);
    const set = new Set(norm.map(([x,y]) => `${x},${y}`));

    for(let gy=0;gy<5;gy++){
      for(let gx=0;gx<5;gx++){
        const key = `${gx-offX},${gy-offY}`;
        const isBlock = set.has(key);
        const b = document.createElement('div');
        b.className = "pblock" + (isBlock ? (mode === 'ghost' ? " gblock" : "") : " empty");
        if(isBlock){
          b.style.background = p.color;
          if(mode === 'tray'){
            b.dataset.localX = String(gx-offX);
            b.dataset.localY = String(gy-offY);
          }
        }
        inner.appendChild(b);
      }
    }
    return inner;
  }

  function renderTray(){
    trayEl.innerHTML = "";
    tray.forEach((p, idx) => {
      const outer = document.createElement('div');
      outer.className = "piece";
      outer.dataset.pieceIndex = idx;

      const inner = renderPieceInner(p, 'tray');
      for(const b of inner.querySelectorAll('.pblock:not(.empty)')){
        b.dataset.pieceIndex = String(idx);
      }
      outer.appendChild(inner);
      trayEl.appendChild(outer);
    });
    updateTrayDisabledStates();
  }

  function updateTrayDisabledStates(){
    // Grey out pieces that cannot be placed anywhere
    const nodes = trayEl.querySelectorAll('.piece');
    tray.forEach((p, idx) => {
      const can = canPlaceSomewhere(p);
      nodes[idx]?.classList.toggle('disabled', !can);
    });
  }

  function refillTrayIfNeeded(){
    if(tray.length === 0){
      tray = [randomPiece(), randomPiece(), randomPiece()];
      renderTray();
    }
  }

  function canPlace(shape, ox, oy){
    for(const [dx,dy] of shape){
      const x = ox + dx;
      const y = oy + dy;
      if(x<0 || x>=N || y<0 || y>=N) return false;
      if(board[y][x]) return false;
    }
    return true;
  }

  function canPlaceSomewhere(piece){
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        if(canPlace(piece.shape, x, y)) return true;
      }
    }
    return false;
  }

  function anyMoveAvailable(){
    for(const p of tray){
      if(canPlaceSomewhere(p)) return true;
    }
    return false;
  }

  function findClears(){
    const fullRows = [];
    const fullCols = [];
    for(let y=0;y<N;y++){
      if(board[y].every(v=>!!v)) fullRows.push(y);
    }
    for(let x=0;x<N;x++){
      let ok = true;
      for(let y=0;y<N;y++){ if(!board[y][x]) {ok=false; break;} }
      if(ok) fullCols.push(x);
    }
    return { fullRows, fullCols };
  }

  function applyClears(fullRows, fullCols){
    for(const y of fullRows){
      for(let x=0;x<N;x++) board[y][x] = null;
    }
    for(const x of fullCols){
      for(let y=0;y<N;y++) board[y][x] = null;
    }
  }

  function place(shape, color, ox, oy){
    for(const [dx,dy] of shape){
      const x = ox + dx;
      const y = oy + dy;
      board[y][x] = color;
    }

    const { fullRows, fullCols } = findClears();
    const cleared = fullRows.length + fullCols.length;

    if(cleared > 0){
      applyClears(fullRows, fullCols);
      comboStreak += 1;
      const base = 50;
      const points = base * cleared * comboStreak;
      setScore(score + points);
      showToast(`+${points}  x${comboStreak}`);
    } else {
      comboStreak = 0;
    }

    renderBoard();
  }

  // Preview
  let previewCells = [];
  let hintCells = [];
  let hintLineCells = [];

  function clearHints(){
    for(const el of hintCells){
      el.classList.remove('hintPlace');
    }
    for(const el of hintLineCells){
      el.classList.remove('hintLine');
    }
    hintCells = [];
    hintLineCells = [];
  }

  function clearPreview(){
    for(const el of previewCells){
      el.querySelectorAll('.ptile').forEach(n => n.remove());
    }
    previewCells = [];
    clearHints();
  }

  function predictClearsIfPlaced(shape, ox, oy){
    // placements set
    const placeSet = new Set();
    for(const [dx,dy] of shape){
      placeSet.add(`${ox+dx},${oy+dy}`);
    }

    const rows = [];
    const cols = [];

    // rows
    for(let y=0;y<N;y++){
      let full = true;
      for(let x=0;x<N;x++){
        if(!board[y][x] && !placeSet.has(`${x},${y}`)){ full = false; break; }
      }
      if(full) rows.push(y);
    }
    // cols
    for(let x=0;x<N;x++){
      let full = true;
      for(let y=0;y<N;y++){
        if(!board[y][x] && !placeSet.has(`${x},${y}`)){ full = false; break; }
      }
      if(full) cols.push(x);
    }
    return { rows, cols, placeSet };
  }

  function applySmartHighlight(ox, oy, shape, color){
    // highlight placement cells + potential clears
    const { rows, cols, placeSet } = predictClearsIfPlaced(shape, ox, oy);

    // placement cells highlight
    for(const key of placeSet){
      const [xStr,yStr] = key.split(',');
      const x = Number(xStr), y = Number(yStr);
      const cell = gridEl.children[y*N + x];
      hintCells.push(cell);
      cell.classList.add('hintPlace');
    }

    // line hints (rows/cols that would clear)
    if(rows.length || cols.length){
      const set = new Set();
      for(const y of rows){
        for(let x=0;x<N;x++) set.add(`${x},${y}`);
      }
      for(const x of cols){
        for(let y=0;y<N;y++) set.add(`${x},${y}`);
      }
      for(const key of set){
        const [xStr,yStr] = key.split(',');
        const x = Number(xStr), y = Number(yStr);
        const cell = gridEl.children[y*N + x];
        hintLineCells.push(cell);
        cell.classList.add('hintLine');
      }
    }
  }

  function showPreview(ox, oy, shape, color){
    clearPreview();
    for(const [dx,dy] of shape){
      const x = ox + dx, y = oy + dy;
      const cell = gridEl.children[y*N + x];
      previewCells.push(cell);
      const p = document.createElement('div');
      p.className = "ptile";
      p.style.setProperty('--fill', color);
      cell.appendChild(p);
    }
    applySmartHighlight(ox, oy, shape, color);
  }


  // Ghost/probe
    const el = document.elementFromPoint(x, y);
    if(!el) return null;
    if(el.classList?.contains('cell')) return el;
    return el.closest?.('.cell') || null;
  }

  function updateGhostPos(clientX, clientY){
    if(!drag) return;
    const cellInfo = getCellFromClientXY(clientX, clientY);
    if(cellInfo){
      snapGhostToCell(cellInfo.gx, cellInfo.gy);
    } else {
      // follow pointer normally
      ghostEl.style.transform = `translate(${clientX + 18}px, ${clientY - 90}px)`;
    }
  }

  function scheduleMove(x,y){
    lastX = x; lastY = y;
    if(rafPending) return;
    rafPending = true;
    requestAnimationFrame(() => {
      rafPending = false;
      if(!drag) return;

      updateGhostPos(lastX, lastY);

      const cellInfo = getCellFromClientXY(lastX, lastY);

      if(cellInfo){
        const gx = cellInfo.gx;
        const gy = cellInfo.gy;
        const ox = gx - drag.grabX;
        const oy = gy - drag.grabY;
        if(canPlace(drag.shape, ox, oy)){
          showPreview(ox, oy, drag.shape, drag.color);
        } else {
          clearPreview();
        }
      } else {
        clearPreview();
      }
    });
  }

  // Fix "need to click many times":
  // Use pointerdown on the piece container + allow slight movement to start drag
  function findPieceIndexFromEventTarget(t){
    const pieceEl = t.closest?.('.piece');
    if(!pieceEl) return null;
    const idx = Number(pieceEl.dataset.pieceIndex);
    return Number.isFinite(idx) ? idx : null;
  }

  function startDrag(pieceIndex, clientX, clientY, pointerId, captureEl){
    const p = tray[pieceIndex];
    if(!p || isGameOver) return;

    // default grab point = first block of shape (top-left after normalize) for stability
    // but if event came from actual block, we’ll override below.
    let grabX = 0, grabY = 0;

    // If pointer down on a specific block, use that
    const target = document.elementFromPoint(clientX, clientY);
    const b = target?.classList?.contains('pblock') && !target.classList.contains('empty') ? target : null;
    if(b && b.dataset.localX != null){
      grabX = Number(b.dataset.localX);
      grabY = Number(b.dataset.localY);
    } else {
      // better: take min coords of shape as grab, feels consistent
      const xs = p.shape.map(c=>c[0]);
      const ys = p.shape.map(c=>c[1]);
      grabX = Math.min(...xs);
      grabY = Math.min(...ys);
    }

    drag = {
      pieceIndex,
      shape: p.shape,
      color: p.color,
      grabX, grabY,
      startX: clientX,
      startY: clientY,
      pointerId
    };

    // mark selected
    trayEl.querySelectorAll('.piece').forEach(n => n.classList.remove('isDragging'));
    const pieceNode = trayEl.children[pieceIndex];
    pieceNode?.classList.add('isDragging');

    // capture pointer
    try { captureEl.setPointerCapture(pointerId); } catch {}

    // create ghost
    ghostEl.innerHTML = "";
    const ghostInner = renderPieceInner(p, 'ghost');
    ghostEl.appendChild(ghostInner);

    // initial up near board
    const boardRect = document.querySelector('.boardShell').getBoundingClientRect();
    const initialX = Math.max(boardRect.left + 10, Math.min(boardRect.right - 10, clientX + 12));
    const initialY = Math.max(10, boardRect.top - 140);
    ghostEl.style.transform = `translate(${initialX}px, ${initialY}px)`;

    scheduleMove(clientX, clientY);
  }

  function endDragCleanup(){
    trayEl.querySelectorAll('.piece').forEach(n => n.classList.remove('isDragging'));
    drag = null;
    ghostEl.innerHTML = "";
    ghostEl.style.transform = "translate(-9999px,-9999px)";
    clearPreview();
  }

  function maybeGameOver(){
    updateTrayDisabledStates();
    if(tray.length > 0 && !anyMoveAvailable()){
      isGameOver = true;
      openModal('gameover');
    }
  }

  // Events
  trayEl.addEventListener('pointerdown', (e) => {
    if(isGameOver) return;
    const idx = findPieceIndexFromEventTarget(e.target);
    if(idx == null) return;
    // prevent starting drag on disabled piece
    if(!canPlaceSomewhere(tray[idx])) {
      showToast("Нет места");
      return;
    }
    startDrag(idx, e.clientX, e.clientY, e.pointerId, e.target);
    e.preventDefault();
  }, {passive:false});

  document.addEventListener('pointermove', (e) => {
    if(!drag) return;
    scheduleMove(e.clientX, e.clientY);
    e.preventDefault();
  }, {passive:false});

  document.addEventListener('pointerup', (e) => {
    if(!drag) return;

    const cellInfo = getCellFromClientXY(e.clientX, e.clientY);

    let placed = false;
    if(cellInfo){
      const gx = cellInfo.gx;
      const gy = cellInfo.gy;
      const ox = gx - drag.grabX;
      const oy = gy - drag.grabY;
      if(canPlace(drag.shape, ox, oy)){
        place(drag.shape, drag.color, ox, oy);
        tray.splice(drag.pieceIndex, 1);
        renderTray();
        refillTrayIfNeeded();
        placed = true;
        maybeGameOver();
      }
    }

    if(!placed) showToast("Нельзя");
    endDragCleanup();

    e.preventDefault();
  }, {passive:false});

  // New game confirmation during play
  newGameBtn.addEventListener('click', () => {
    if(isGameOver){
      newGame();
      return;
    }
    openModal('confirm');
  });

  // Modal buttons
  modalPrimary.addEventListener('click', () => {
    closeModal();
    newGame();
  });
  modalSecondary.addEventListener('click', () => {
    closeModal();
  });
  overlay.addEventListener('pointerdown', (e) => {
    // tap outside closes only for confirm, not for gameover
    if(e.target === overlay && !isGameOver){
      closeModal();
    }
  });

  function newGame(){
    isGameOver = false;
    closeModal();
    board = Array.from({length:N}, () => Array(N).fill(null));
    tray = [randomPiece(), randomPiece(), randomPiece()];
    comboStreak = 0;
    setScore(0);
    bestEl.textContent = String(best);
    renderBoard();
    renderTray();
  }

  // TON Connect (привязка кошелька) + баланс
  // ВАЖНО: для продакшена лучше использовать свой endpoint и/или API key.
  // Manifest должен быть доступен по HTTPS. Положи рядом файл tonconnect-manifest.json и укажи его URL.
  const TONCONNECT_MANIFEST_URL = (location.origin + location.pathname.replace(/\/[^\/]*$/, '/') + 'tonconnect-manifest.json');

  let tonConnectUI = null;
  async function initTonConnect(){
    if(!window.TonConnectUI){
      tonBalanceEl.textContent = "TON недоступен";
      return;
    }
    tonConnectUI = new window.TonConnectUI.TonConnectUI({
      manifestUrl: TONCONNECT_MANIFEST_URL,
      buttonRootId: "tonconnect-button",
      // Если в Telegram Mini App возникают проблемы с возвратом в приложение,
      // можно настроить return strategy в документации TonConnect UI.
    });

    // restore
    try { await tonConnectUI.connector.restoreConnection(); } catch {}

    // subscribe
    tonConnectUI.onStatusChange(async (wallet) => {
      if(wallet){
        const addr = wallet.account?.address || "";
        tonAddrEl.textContent = addr ? (addr.slice(0,6) + "…" + addr.slice(-6)) : "";
        await refreshTonBalance(addr);
      } else {
        tonAddrEl.textContent = "";
        tonBalanceEl.textContent = "—";
      }
    });

    // initial status
    const w = tonConnectUI.wallet;
    if(w?.account?.address){
      tonAddrEl.textContent = w.account.address.slice(0,6) + "…" + w.account.address.slice(-6);
      await refreshTonBalance(w.account.address);
    }
  }

  async function refreshTonBalance(address){
    if(!address){
      tonBalanceEl.textContent = "—";
      return;
    }
    // Toncenter getAddressBalance (nanotons). Может требовать api_key при лимитах.
    const url = new URL("https://toncenter.com/api/v2/getAddressBalance");
    url.searchParams.set("address", address);

    try{
      const r = await fetch(url.toString(), { method:"GET" });
      const j = await r.json();
      if(j && j.ok && j.result != null){
        const nanotons = BigInt(j.result);
        const ton = Number(nanotons) / 1e9;
        tonBalanceEl.textContent = (Math.floor(ton*1000)/1000).toFixed(3) + " TON";
      } else {
        tonBalanceEl.textContent = "нет данных";
      }
    } catch {
      tonBalanceEl.textContent = "ошибка";
    }
  }


  // init
  buildGrid();
  initTonConnect();
  bestEl.textContent = String(best);
  newGame();
})();
</script>
</body>
</html>
