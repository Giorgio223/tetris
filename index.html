<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>8×8 Blocks</title>
  <style>
    :root{
      --bg1:#3f5da8;
      --bg2:#3a579e;

      --cell:#1b2b52;
      --cell2:#182747;

      --text:#ffffff;
      --yellow:#ffcf3f;

      --wrapW: min(560px, 96vw);

      --cellSize: clamp(24px, 6.05vw, 34px);
      --gap: 1px;

      --trayB: 16px;
      --trayGap: 2px;

      --ghostB: 24px;
      --ghostGap: 4px;

      --shadow: 0 18px 40px rgba(0,0,0,.28);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      background: linear-gradient(180deg, var(--bg1) 0%, var(--bg2) 100%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;
      color:var(--text);
      user-select:none;
      -webkit-user-select:none;
      touch-action:none;
      overflow:auto;
      padding-bottom: 18px;
    }

    .wrap{
      width:var(--wrapW);
      display:flex;
      flex-direction:column;
      gap:10px;
      padding: 14px 0;
    }

    /* top */
    .top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      padding: 6px 6px;
      gap:10px;
    }
    .leftScore{
      display:flex;
      align-items:baseline;
      gap:10px;
    }
    .scoreBig{
      font-weight: 1000;
      font-size: 44px;
      line-height: 1;
      letter-spacing: .5px;
      text-shadow: 0 3px 0 rgba(0,0,0,.18);
      font-variant-numeric: tabular-nums;
    }

    button{
      background: rgba(0,0,0,.14);
      color:#fff;
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 999px;
      padding: 10px 14px;
      font-weight: 950;
      cursor:pointer;
      box-shadow: 0 6px 0 rgba(0,0,0,.14);
      white-space:nowrap;
    }
    button:active{transform: translateY(1px); box-shadow: 0 5px 0 rgba(0,0,0,.14)}
    .btnSecondary{ background: rgba(255,255,255,.08); }

    .sideBtn{
      display:flex;
      align-items:flex-start;
      gap:12px;
    }

    .balanceBox{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:4px;
      margin-right: 6px;
      min-width: 120px;
    }
    .balanceLabel{
      font-weight: 950;
      font-size: 12px;
      opacity:.92;
      letter-spacing:.3px;
    }
    .balanceValue{
      font-weight: 1000;
      font-size: 18px;
      color: var(--yellow);
      font-variant-numeric: tabular-nums;
      text-shadow: 0 2px 0 rgba(0,0,0,.18);
    }
    .balanceAddr{
      font-size: 11px;
      opacity:.78;
      max-width: 220px;
      overflow:hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .tonBtn{ display:flex; justify-content:flex-end; }

    .boardShell{
      background: rgba(20,30,58,.22);
      padding: 10px;
      border-radius: 22px;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.06), var(--shadow);
    }
    .board{
      background: linear-gradient(180deg, #22356a 0%, #1c2c58 100%);
      border-radius: 18px;
      padding: 10px;
      box-shadow: inset 0 0 0 3px rgba(0,0,0,.18);
    }
    .grid{
      display:grid;
      grid-template-columns: repeat(8, var(--cellSize));
      grid-template-rows: repeat(8, var(--cellSize));
      gap: var(--gap);
      justify-content:center;
      background: rgba(0,0,0,.16);
      padding: var(--gap);
      border-radius: 14px;
    }

    .cell{
      position:relative;
      border-radius: 7px;
      background: linear-gradient(180deg, var(--cell) 0%, var(--cell2) 100%);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.035);
      overflow:hidden;
    }

    /* Smart highlight */
    .cell.hintPlace{
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,.22),
        0 0 0 2px rgba(255,255,255,.06);
    }
    .cell.hintLine{
      box-shadow:
        inset 0 0 0 2px rgba(255,207,63,.35),
        0 0 18px rgba(255,207,63,.14);
      animation: hintPulse .6s ease-in-out infinite alternate;
    }
    @keyframes hintPulse{
      from{ filter: brightness(1); }
      to{ filter: brightness(1.12); }
    }

    .tile, .ptile{
      position:absolute;
      inset: -2px;
      border-radius: 7px;
      background: var(--fill, #ff6b6b);
      box-shadow:
        inset 0 2px 0 rgba(255,255,255,.22),
        inset 0 -3px 0 rgba(0,0,0,.22),
        inset 3px 0 0 rgba(255,255,255,.14),
        inset -3px 0 0 rgba(0,0,0,.18),
        0 3px 0 rgba(0,0,0,.10);
    }
    .ptile{
      opacity: .48;
      filter: saturate(1.08);
      box-shadow:
        inset 0 2px 0 rgba(255,255,255,.18),
        inset 0 -3px 0 rgba(0,0,0,.18),
        inset 3px 0 0 rgba(255,255,255,.10),
        inset -3px 0 0 rgba(0,0,0,.14);
    }

    /* Remove decorative dots/marks */
    .tile::before, .tile::after,
    .ptile::before, .ptile::after,
    .pblock::before, .pblock::after{
      display:none !important;
      content:none !important;
    }

    .tray{
      display:flex;
      justify-content:space-between;
      gap:14px;
      padding-top: 6px;
    }
    .piece{
      flex:1;
      min-width:0;
      display:grid;
      place-items:center;
      padding: 10px 6px;
      border-radius: 14px;
      background: rgba(10,16,32,.12);
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.06);
      cursor:grab;
      transition: transform .08s ease, filter .08s ease, opacity .15s ease;
    }
    .piece:active{cursor:grabbing}
    .piece.isDragging{
      filter: saturate(1.05);
      transform: translateY(-6px);
    }
    .piece.disabled{ opacity:.55; }

    .pieceInner{
      --b: var(--trayB);
      --g: var(--trayGap);
      display:grid;
      gap: var(--g);
      grid-template-columns: repeat(5, var(--b));
      grid-template-rows: repeat(5, var(--b));
      width: calc(5*var(--b) + 4*var(--g));
      height: calc(5*var(--b) + 4*var(--g));
    }

    .pblock{
      width:var(--b); height:var(--b);
      border-radius: 6px;
      background: var(--pcolor, #ff6b6b);
      box-shadow:
        inset 0 2px 0 rgba(255,255,255,.22),
        inset 0 -3px 0 rgba(0,0,0,.20),
        inset 3px 0 0 rgba(255,255,255,.14),
        inset -3px 0 0 rgba(0,0,0,.18),
        0 2px 0 rgba(0,0,0,.10);
      position:relative;
    }
    .pblock.empty{
      background: transparent;
      box-shadow:none;
    }

    .dragGhost{
      position:fixed;
      left:0; top:0;
      transform: translate(-9999px,-9999px);
      z-index:9999;
      pointer-events:none;
      opacity:.98;
      will-change: transform;
      filter: drop-shadow(0 14px 26px rgba(0,0,0,.35));
    }
    /* Keep 5×5 grid but hide empties */
    .dragGhost .pblock.empty{ visibility:hidden; }

    /* Drag ghost: crisp block + smaller shadow */
    .dragGhost .pblock{ position: relative; z-index: 1; }
    .dragGhost .pblock.gblock::after{
      content:"";
      position:absolute;
      inset: 3px;
      border-radius: 6px;
      background: rgba(0,0,0,.28);
      transform: translate(-8px,-8px) scale(0.86);
      z-index: -1;
      box-shadow: 0 2px 0 rgba(0,0,0,.12);
    }
    .dragGhost .pieceInner{
      --b: var(--ghostB);
      --g: var(--ghostGap);
    }

    /* Controls panel */
    .bottomBar{
      display:flex;
      flex-direction:column;
      gap:8px;
      justify-content:center;
      align-items:center;
      padding: 10px 8px calc(16px + env(safe-area-inset-bottom));
    }
    .ctrl{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      justify-content:center;
      align-items:center;
      width: 100%;
    }
    .amtLabel{
      display:flex;
      flex-direction:column;
      gap:6px;
      font-weight: 900;
      font-size: 12px;
      opacity:.92;
      text-align:left;
      min-width: 140px;
    }
    .amtLabel input{
      width: 140px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(0,0,0,.14);
      color:#fff;
      outline:none;
      font-weight: 900;
    }
    .amtLabel input::placeholder{color: rgba(255,255,255,.55)}
    .ctrlHint{
      font-size: 12px;
      opacity: .8;
      text-align:center;
      min-height: 16px;
    }

    .toast{
      position:fixed;
      bottom:16px;
      left:50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.16);
      color:#fff;
      padding:10px 14px;
      border-radius: 999px;
      font-weight:950;
      font-size:13px;
      opacity:0;
      transition: opacity .18s ease;
      pointer-events:none;
    }
    .toast.show{opacity:1}

    /* Modal */
    .overlay{
      position:fixed;
      inset:0;
      display:none;
      place-items:center;
      background: rgba(0,0,0,.35);
      backdrop-filter: blur(3px);
      z-index: 10000;
    }
    .overlay.show{display:grid}
    .modal{
      width: min(420px, 90vw);
      background: rgba(20,28,54,.92);
      border:1px solid rgba(255,255,255,.16);
      border-radius: 22px;
      box-shadow: 0 22px 60px rgba(0,0,0,.35);
      padding: 18px 16px 14px;
      text-align:center;
    }
    .modal h2{
      margin:6px 0 8px;
      font-size: 28px;
      letter-spacing:.6px;
    }
    .modal p{
      margin:0 0 14px;
      color: rgba(255,255,255,.85);
      font-weight:800;
    }
    .modal .row{
      display:flex;
      gap:10px;
      justify-content:center;
      margin-top: 10px;
      flex-wrap:wrap;
    }
  
    /* Controls grid: tidy buttons */
    .ctrlGrid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:10px;
      width: 100%;
    }
    @media (max-width: 420px){
      .ctrlGrid{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
    }
    .ctrlGrid button{
      width:100%;
      padding: 12px 14px;
      font-size: 15px;
    }
    .btnPrimary{
      background: rgba(255,207,63,.18);
      border-color: rgba(255,207,63,.28);
      box-shadow: 0 6px 0 rgba(0,0,0,.14);
    }

    /* Hide TonConnect root button UI (we open via our own button) */
    #tonconnect-button{ display:none; }

    .moneyRow{ display:flex; justify-content:center; margin: 10px 0 6px; }
    #moneyAmountInput{
      width: 180px;
      text-align:center;
      font-size: 16px;
    }

</style>

  <!-- TON Connect UI + TonWeb (for comment payload) -->
  <script src="https://cdn.jsdelivr.net/npm/@tonconnect/ui@2.3.1/dist/tonconnect-ui.min.js"></script>
  <script src="https://unpkg.com/tonweb@0.0.66/dist/tonweb.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="leftScore">
        <div class="scoreBig" id="score">0</div>
      </div>

      <div class="sideBtn">
        <div class="balanceBox" title="TON кошелек и баланс">
          <span class="balanceLabel">Баланс:</span>
          <span class="balanceValue" id="tonBalance">—</span>
          <span class="balanceAddr" id="tonAddr"></span>
          <div class="tonBtn" id="tonconnect-button"></div>
        </div>
      </div>
    </div>

    <div class="boardShell">
      <div class="board">
        <div class="grid" id="grid"></div>
      </div>
    </div>

    <div class="tray" id="tray"></div>

    
    <div class="bottomBar">
      <div class="ctrlGrid">
        <button id="startGameBtn">Начать игру</button>
        <button id="connectWalletBtn">Привязать кошелёк</button>
        <button id="depositOpenBtn">Депозит</button>

        <button id="startRoundBtn" class="btnPrimary">Начать раунд</button>
        <button id="withdrawOpenBtn" class="btnSecondary">Вывод</button>
        <button id="newGameBtnBottom" class="btnSecondary">Новая игра</button>
      </div>
      <div class="ctrlHint" id="ctrlHint"></div>
    </div>

  </div>

  <div class="dragGhost" id="ghost"></div>
  <div class="toast" id="toast"></div>

  <div class="overlay" id="overlay">
    <div class="modal">
      <h2 id="modalTitle">GAME OVER</h2>
      <p id="modalText">Ходов больше нет.</p>
      <div class="row">
        <button id="modalPrimary">Новая игра</button>
        <button class="btnSecondary" id="modalSecondary">Отмена</button>
      </div>


  <!-- Deposit modal -->
  <div class="overlay" id="moneyOverlay" style="display:none;">
    <div class="modal">
      <h2 id="moneyTitle">Депозит</h2>
      <p id="moneyText">Введите сумму в TON и подтвердите.</p>
      <div class="moneyRow">
        <label class="amtLabel" style="align-items:center; text-align:center; min-width:auto;">
          Сумма (TON)
          <input id="moneyAmountInput" inputmode="decimal" placeholder="0.1" />
        </label>
      </div>
      <div class="row">
        <button id="moneyConfirmBtn">Подтвердить</button>
        <button class="btnSecondary" id="moneyCancelBtn">Отмена</button>
      </div>
    </div>
  </div>

</div>
    </div>
  </div>

<script>
(() => {
  const N = 8;

  const gridEl = document.getElementById('grid');
  const trayEl = document.getElementById('tray');
  const scoreEl = document.getElementById('score');
  const ghostEl = document.getElementById('ghost');
  const toastEl = document.getElementById('toast');

  
  const tonBalanceEl = document.getElementById('tonBalance');
  const tonAddrEl = document.getElementById('tonAddr');

    const startGameBtn = document.getElementById('startGameBtn');
  const connectWalletBtn = document.getElementById('connectWalletBtn');
  const depositOpenBtn = document.getElementById('depositOpenBtn');
  const startRoundBtn = document.getElementById('startRoundBtn');
  const withdrawOpenBtn = document.getElementById('withdrawOpenBtn');
  const newGameBtn = document.getElementById('newGameBtnBottom');
    const ctrlHint = document.getElementById('ctrlHint');
  const moneyOverlay = document.getElementById('moneyOverlay');
  const moneyTitle = document.getElementById('moneyTitle');
  const moneyText = document.getElementById('moneyText');
  const moneyAmountInput = document.getElementById('moneyAmountInput');
  const moneyConfirmBtn = document.getElementById('moneyConfirmBtn');
  const moneyCancelBtn = document.getElementById('moneyCancelBtn');

  const overlay = document.getElementById('overlay');
  const modalTitle = document.getElementById('modalTitle');
  const modalText  = document.getElementById('modalText');
  const modalPrimary = document.getElementById('modalPrimary');
  const modalSecondary = document.getElementById('modalSecondary');

  let board = Array.from({length:N}, () => Array(N).fill(null));
  let tray = [];
  let score = 0;

  let comboStreak = 0;
  let isGameOver = false;

  // ONE declaration only
  let roundDepositNanotons = 0n;
  let roundStartedAt = null; // ms

  // TON UI
  let tonConnectUI = null;

  // server round
  let roundId = null;

  const COLORS = ["#ff4d4d","#ffcf3f","#3fe36b","#4d7dff","#c85cff","#ff62d4"];
  const SHAPES = [
    [[0,0]],
    [[0,0],[1,0]],
    [[0,0],[1,0],[2,0]],
    [[0,0],[0,1],[0,2]],
    [[0,0],[1,0],[0,1],[1,1]],
    [[0,0],[1,0],[2,0],[3,0]],
    [[0,0],[0,1],[1,1]],
    [[1,0],[1,1],[0,1]],
    [[0,0],[1,0],[2,0],[1,1]],
    [[0,0],[0,1],[0,2],[1,2]],
    [[1,0],[1,1],[1,2],[0,2]],
    [[0,0],[1,0],[2,0],[3,0],[4,0]],
    [[0,0],[0,1],[1,1],[1,2]],
    [[1,0],[1,1],[0,1],[0,2]],
    [[0,0],[1,0],[2,0],[0,1],[1,1],[2,1]],
    [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2]],
  ];

  // ===== UI helpers =====
  function setScore(v){
    score = v;
    scoreEl.textContent = String(score);
  }

  function setHint(msg){
    ctrlHint.textContent = msg || "";
  }


  let moneyMode = null; // 'deposit' | 'withdraw' | 'stake'
  function openMoneyModal(mode){
    moneyMode = mode;
    moneyAmountInput.value = "";
    moneyOverlay.style.display = "grid";
    if(mode === "deposit"){
      moneyTitle.textContent = "Депозит";
      moneyText.textContent = "Введите сумму депозита в TON и подтвердите перевод.";
      moneyConfirmBtn.textContent = "Подтвердить";
    } else if(mode === "withdraw"){
      moneyTitle.textContent = "Вывод";
      moneyText.textContent = "Введите сумму вывода в TON. Будет создана заявка (pending).";
      moneyConfirmBtn.textContent = "Создать заявку";
    } else {
      moneyTitle.textContent = "Ставка";
      moneyText.textContent = "Введите сумму ставки в TON. Ставка списывается с баланса и начинается раунд.";
      moneyConfirmBtn.textContent = "Начать раунд";
    }
  }
  function closeMoneyModal(){
    moneyOverlay.style.display = "none";
    moneyMode = null;
  }


  function showToast(msg){
    toastEl.textContent = msg;
    toastEl.classList.add('show');
    clearTimeout(showToast._t);
    showToast._t = setTimeout(()=>toastEl.classList.remove('show'), 900);
  }

  function openModal(type){
    overlay.classList.add('show');
    if(type === 'gameover'){
      modalTitle.textContent = "GAME OVER";
      modalText.textContent = "Ходов больше нет.";
      modalSecondary.style.display = "none";
    } else {
      modalTitle.textContent = "Новая игра?";
      modalText.textContent = "Вы уверены начать новую игру?";
      modalSecondary.style.display = "";
    }
  }

  function closeModal(){
    overlay.classList.remove('show');
  }

  // ===== Board =====
  function buildGrid(){
    gridEl.innerHTML = "";
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const c = document.createElement('div');
        c.className = "cell";
        c.dataset.x = x;
        c.dataset.y = y;
        gridEl.appendChild(c);
      }
    }
  }

  function renderBoard(){
    const cells = gridEl.children;
    let i = 0;
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const el = cells[i++];
        const col = board[y][x];
        el.querySelectorAll('.tile').forEach(n => n.remove());
        if(col){
          const t = document.createElement('div');
          t.className = "tile";
          t.style.setProperty('--fill', col);
          el.appendChild(t);
        }
      }
    }
  }

  function cryptoRandomId(){
    if(window.crypto?.getRandomValues){
      const a = new Uint32Array(1);
      window.crypto.getRandomValues(a);
      return "p" + a[0].toString(16);
    }
    return "p" + Math.random().toString(16).slice(2);
  }

  function difficultyBias(){
    if(score < 7000) return 0;
    if(score < 15000) return 0.15;
    return 0.25;
  }

  function randomPiece(){
    const bias = difficultyBias();
    const bySize = SHAPES.map(s => ({s, k:s.length}));
    const big = bySize.filter(o => o.k >= 4).map(o=>o.s);
    const pickFrom = (Math.random() < bias && big.length) ? big : SHAPES;
    const shape = pickFrom[(Math.random()*pickFrom.length)|0];
    const color = COLORS[(Math.random()*COLORS.length)|0];
    return { shape, color, id: cryptoRandomId() };
  }

  function renderPieceInner(p, mode /* tray|ghost */){
    const inner = document.createElement('div');
    inner.className = "pieceInner";
    inner.style.setProperty('--pcolor', p.color);

    const coords = p.shape;
    const xs = coords.map(c=>c[0]), ys = coords.map(c=>c[1]);
    const minX = Math.min(...xs), minY = Math.min(...ys);
    const norm = coords.map(([x,y]) => [x-minX, y-minY]);
    const w = Math.max(...norm.map(c=>c[0])) + 1;
    const h = Math.max(...norm.map(c=>c[1])) + 1;
    const offX = Math.floor((5 - w)/2);
    const offY = Math.floor((5 - h)/2);
    const set = new Set(norm.map(([x,y]) => `${x},${y}`));

    for(let gy=0;gy<5;gy++){
      for(let gx=0;gx<5;gx++){
        const key = `${gx-offX},${gy-offY}`;
        const isBlock = set.has(key);
        const b = document.createElement('div');
        b.className = "pblock" + (isBlock ? (mode === 'ghost' ? " gblock" : "") : " empty");
        if(isBlock){
          b.style.background = p.color;
          if(mode === 'tray'){
            b.dataset.localX = String(gx-offX);
            b.dataset.localY = String(gy-offY);
          }
        }
        inner.appendChild(b);
      }
    }
    return inner;
  }

  function renderTray(){
    trayEl.innerHTML = "";
    tray.forEach((p, idx) => {
      const outer = document.createElement('div');
      outer.className = "piece";
      outer.dataset.pieceIndex = idx;

      outer.appendChild(renderPieceInner(p, 'tray'));
      trayEl.appendChild(outer);
    });
    updateTrayDisabledStates();
  }

  function refillTrayIfNeeded(){
    if(tray.length === 0){
      tray = [randomPiece(), randomPiece(), randomPiece()];
      renderTray();
    }
  }

  function canPlace(shape, ox, oy){
    for(const [dx,dy] of shape){
      const x = ox + dx;
      const y = oy + dy;
      if(x<0 || x>=N || y<0 || y>=N) return false;
      if(board[y][x]) return false;
    }
    return true;
  }

  function canPlaceSomewhere(piece){
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        if(canPlace(piece.shape, x, y)) return true;
      }
    }
    return false;
  }

  function anyMoveAvailable(){
    for(const p of tray){
      if(canPlaceSomewhere(p)) return true;
    }
    return false;
  }

  function updateTrayDisabledStates(){
    const nodes = trayEl.querySelectorAll('.piece');
    tray.forEach((p, idx) => {
      const can = canPlaceSomewhere(p);
      nodes[idx]?.classList.toggle('disabled', !can);
    });
  }

  function findClears(){
    const fullRows = [];
    const fullCols = [];
    for(let y=0;y<N;y++){
      if(board[y].every(v=>!!v)) fullRows.push(y);
    }
    for(let x=0;x<N;x++){
      let ok = true;
      for(let y=0;y<N;y++){ if(!board[y][x]) {ok=false; break;} }
      if(ok) fullCols.push(x);
    }
    return { fullRows, fullCols };
  }

  function applyClears(fullRows, fullCols){
    for(const y of fullRows){
      for(let x=0;x<N;x++) board[y][x] = null;
    }
    for(const x of fullCols){
      for(let y=0;y<N;y++) board[y][x] = null;
    }
  }

  function place(shape, color, ox, oy){
    for(const [dx,dy] of shape){
      board[oy+dy][ox+dx] = color;
    }

    const { fullRows, fullCols } = findClears();
    const cleared = fullRows.length + fullCols.length;

    if(cleared > 0){
      applyClears(fullRows, fullCols);
      comboStreak += 1;
      const base = 50;
      const points = base * cleared * comboStreak;
      setScore(score + points);
      showToast(`+${points}  x${comboStreak}`);
    } else {
      comboStreak = 0;
    }

    renderBoard();
    saveRound();
  }

  // ===== Preview + smart hint =====
  let previewCells = [];
  let hintCells = [];
  let hintLineCells = [];

  function clearHints(){
    for(const el of hintCells) el.classList.remove('hintPlace');
    for(const el of hintLineCells) el.classList.remove('hintLine');
    hintCells = [];
    hintLineCells = [];
  }

  function clearPreview(){
    for(const el of previewCells){
      el.querySelectorAll('.ptile').forEach(n => n.remove());
    }
    previewCells = [];
    clearHints();
  }

  function predictClearsIfPlaced(shape, ox, oy){
    const placeSet = new Set();
    for(const [dx,dy] of shape){
      placeSet.add(`${ox+dx},${oy+dy}`);
    }

    const rows = [];
    const cols = [];

    for(let y=0;y<N;y++){
      let full = true;
      for(let x=0;x<N;x++){
        if(!board[y][x] && !placeSet.has(`${x},${y}`)){ full = false; break; }
      }
      if(full) rows.push(y);
    }
    for(let x=0;x<N;x++){
      let full = true;
      for(let y=0;y<N;y++){
        if(!board[y][x] && !placeSet.has(`${x},${y}`)){ full = false; break; }
      }
      if(full) cols.push(x);
    }
    return { rows, cols, placeSet };
  }

  function applySmartHighlight(ox, oy, shape){
    const { rows, cols, placeSet } = predictClearsIfPlaced(shape, ox, oy);

    for(const key of placeSet){
      const [xStr,yStr] = key.split(',');
      const x = Number(xStr), y = Number(yStr);
      const cell = gridEl.children[y*N + x];
      hintCells.push(cell);
      cell.classList.add('hintPlace');
    }

    if(rows.length || cols.length){
      const set = new Set();
      for(const y of rows){ for(let x=0;x<N;x++) set.add(`${x},${y}`); }
      for(const x of cols){ for(let y=0;y<N;y++) set.add(`${x},${y}`); }
      for(const key of set){
        const [xStr,yStr] = key.split(',');
        const x = Number(xStr), y = Number(yStr);
        const cell = gridEl.children[y*N + x];
        hintLineCells.push(cell);
        cell.classList.add('hintLine');
      }
    }
  }

  function showPreview(ox, oy, shape, color){
    clearPreview();
    for(const [dx,dy] of shape){
      const x = ox + dx, y = oy + dy;
      const cell = gridEl.children[y*N + x];
      previewCells.push(cell);
      const p = document.createElement('div');
      p.className = "ptile";
      p.style.setProperty('--fill', color);
      cell.appendChild(p);
    }
    applySmartHighlight(ox, oy, shape);
  }

  // ===== Dragging =====
  let drag = null;
  let rafPending = false;
  let lastX = 0, lastY = 0;

  function getCellFromClientXY(clientX, clientY){
    const rect = gridEl.getBoundingClientRect();
    if(clientX < rect.left || clientX > rect.right || clientY < rect.top || clientY > rect.bottom) return null;

    const firstCell = gridEl.children[0];
    if(!firstCell) return null;
    const cellRect = firstCell.getBoundingClientRect();
    const gridStyle = getComputedStyle(gridEl);
    const gap = parseFloat(gridStyle.gap || gridStyle.columnGap || "0") || 0;

    const stepX = cellRect.width + gap;
    const stepY = cellRect.height + gap;

    const rx = clientX - rect.left;
    const ry = clientY - rect.top;

    const gx = Math.floor(rx / stepX);
    const gy = Math.floor(ry / stepY);

    if(gx < 0 || gx >= N || gy < 0 || gy >= N) return null;
    return { gx, gy };
  }

  function snapGhostToCell(gx, gy){
    const cell = gridEl.children[gy*N + gx];
    const r = cell.getBoundingClientRect();
    const x = r.left + r.width/2;
    const y = r.top + r.height/2 - 22; // slightly above finger
    ghostEl.style.transform = `translate(${x}px, ${y}px) translate(-50%, -50%)`;
  }

  function updateGhostPos(clientX, clientY){
    if(!drag) return;
    const cellInfo = getCellFromClientXY(clientX, clientY);
    if(cellInfo){
      snapGhostToCell(cellInfo.gx, cellInfo.gy);
    } else {
      ghostEl.style.transform = `translate(${clientX + 18}px, ${clientY - 90}px)`;
    }
  }

  function scheduleMove(x,y){
    lastX = x; lastY = y;
    if(rafPending) return;
    rafPending = true;
    requestAnimationFrame(() => {
      rafPending = false;
      if(!drag) return;

      updateGhostPos(lastX, lastY);

      const cellInfo = getCellFromClientXY(lastX, lastY);
      if(cellInfo){
        const ox = cellInfo.gx - drag.grabX;
        const oy = cellInfo.gy - drag.grabY;
        if(canPlace(drag.shape, ox, oy)) showPreview(ox, oy, drag.shape, drag.color);
        else clearPreview();
      } else {
        clearPreview();
      }
    });
  }

  function findPieceIndexFromEventTarget(t){
    const pieceEl = t.closest?.('.piece');
    if(!pieceEl) return null;
    const idx = Number(pieceEl.dataset.pieceIndex);
    return Number.isFinite(idx) ? idx : null;
  }

  function startDrag(pieceIndex, clientX, clientY, pointerId, captureEl){
    const p = tray[pieceIndex];
    if(!p || isGameOver) return;

    let grabX = 0, grabY = 0;

    const target = document.elementFromPoint(clientX, clientY);
    const b = (target && target.classList && target.classList.contains('pblock') && !target.classList.contains('empty')) ? target : null;
    if(b && b.dataset.localX != null){
      grabX = Number(b.dataset.localX);
      grabY = Number(b.dataset.localY);
    } else {
      const xs = p.shape.map(c=>c[0]);
      const ys = p.shape.map(c=>c[1]);
      grabX = Math.min(...xs);
      grabY = Math.min(...ys);
    }

    drag = { pieceIndex, shape:p.shape, color:p.color, grabX, grabY, pointerId };

    trayEl.querySelectorAll('.piece').forEach(n => n.classList.remove('isDragging'));
    trayEl.children[pieceIndex]?.classList.add('isDragging');

    try { captureEl.setPointerCapture(pointerId); } catch {}

    ghostEl.innerHTML = "";
    ghostEl.appendChild(renderPieceInner(p, 'ghost'));

    scheduleMove(clientX, clientY);
  }

  function endDragCleanup(){
    trayEl.querySelectorAll('.piece').forEach(n => n.classList.remove('isDragging'));
    drag = null;
    ghostEl.innerHTML = "";
    ghostEl.style.transform = "translate(-9999px,-9999px)";
    clearPreview();
  }

  function maybeGameOver(){
    updateTrayDisabledStates();
    if(tray.length > 0 && !anyMoveAvailable()){
      isGameOver = true;
      openModal('gameover');
    }
  }

  trayEl.addEventListener('pointerdown', (e) => {
    if(isGameOver) return;
    const idx = findPieceIndexFromEventTarget(e.target);
    if(idx == null) return;

    if(!canPlaceSomewhere(tray[idx])) {
      showToast("Нет места");
      return;
    }
    startDrag(idx, e.clientX, e.clientY, e.pointerId, e.target);
    e.preventDefault();
  }, {passive:false});

  document.addEventListener('pointermove', (e) => {
    if(!drag) return;
    scheduleMove(e.clientX, e.clientY);
    e.preventDefault();
  }, {passive:false});

  document.addEventListener('pointerup', (e) => {
    if(!drag) return;

    const cellInfo = getCellFromClientXY(e.clientX, e.clientY);
    let placed = false;

    if(cellInfo){
      const ox = cellInfo.gx - drag.grabX;
      const oy = cellInfo.gy - drag.grabY;
      if(canPlace(drag.shape, ox, oy)){
        place(drag.shape, drag.color, ox, oy);
        tray.splice(drag.pieceIndex, 1);
        renderTray();
        refillTrayIfNeeded();
        placed = true;
        maybeGameOver();
        saveRound();
      }
    }

    if(!placed) showToast("Нельзя");
    endDragCleanup();
    e.preventDefault();
  }, {passive:false});

  // ===== Local round cache (1 hour) =====
  const ROUND_TTL_MS = 60 * 60 * 1000;
  const ROUND_KEY = "bb_round_v2";

  function nowMs(){ return Date.now(); }

  function saveRound(){
    try{
      const data = {
        v: 2,
        savedAt: nowMs(),
        board,
        tray,
        score,
        comboStreak,
        isGameOver,
        depositNanotons: roundDepositNanotons.toString(),
        startedAt: roundStartedAt
      };
      localStorage.setItem(ROUND_KEY, JSON.stringify(data));
    } catch {}
    scheduleServerSave();
  }

  function clearSavedRound(){
    try{ localStorage.removeItem(ROUND_KEY); } catch {}
  }

  function loadRound(){
    try{
      const raw = localStorage.getItem(ROUND_KEY);
      if(!raw) return false;
      const data = JSON.parse(raw);
      if(!data || data.v !== 2) return false;
      if(!data.savedAt || nowMs() - data.savedAt > ROUND_TTL_MS) return false;

      board = data.board || board;
      tray = data.tray || tray;
      comboStreak = Number(data.comboStreak || 0);
      isGameOver = !!data.isGameOver;
      roundDepositNanotons = BigInt(data.depositNanotons || "0");
      roundStartedAt = data.startedAt || null;
      setScore(Number(data.score || 0));

      renderBoard();
      renderTray();
      if(isGameOver) openModal('gameover');
      setHint("Раунд восстановлен (локально, до 1 часа).");
      return true;
    } catch {
      return false;
    }
  }

  // ===== Backend (Vercel API + Upstash) =====
  async function apiPost(url, data){
    const r = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(data || {})
    });
    return await r.json();
  }

  function requireWalletOrHint(){
    if(!tonConnectUI || !tonConnectUI.wallet || !tonConnectUI.wallet.account?.address){
      setHint("Подключи TON кошелёк.");
      return null;
    }
    return tonConnectUI.wallet.account.address;
  }

  async function refreshInternalBalance(address){
    try{
      const r = await fetch(`/api/balance?address=${encodeURIComponent(address)}`);
      const j = await r.json();
      if(j && j.ok){
        const nano = BigInt(j.balanceNano || "0");
        const ton = Number(nano) / 1e9;
        tonBalanceEl.textContent = (Math.floor(ton*1000)/1000).toFixed(3) + " TON";
      }
    } catch {}
  }

  async function upsertUserAndLoadBalance(address){
    try{ await apiPost("/api/user/upsert", { tonAddress: address }); } catch {}
    await refreshInternalBalance(address);
  }

  async function createCommentPayloadBase64(text){
    if(!window.TonWeb) return null;
    const cell = new TonWeb.boc.Cell();
    cell.bits.writeUint(0, 32);
    cell.bits.writeString(text);
    const boc = await cell.toBoc(false);
    return TonWeb.utils.bytesToBase64(boc);
  }

  async function loadServerRoundIfAny(address){
    try{
      const r = await fetch(`/api/round/get?address=${encodeURIComponent(address)}`);
      const j = await r.json();
      if(j && j.ok && j.round && !j.round.ended){
        roundId = j.round.id;
        if(j.round.state){
          const st = j.round.state;
          board = st.board || board;
          tray = st.tray || tray;
          comboStreak = Number(st.comboStreak || 0);
          isGameOver = !!st.isGameOver;
          setScore(Number(st.score || 0));
          renderBoard();
          renderTray();
          setHint("Раунд восстановлен (сервер, до 1 часа).");
        }
        return true;
      }
    } catch {}
    return false;
  }

  let saveTimer = null;
  function scheduleServerSave(){
    if(!roundId) return;
    if(saveTimer) return;
    saveTimer = setTimeout(async () => {
      saveTimer = null;
      const addr = requireWalletOrHint();
      if(!addr) return;
      try{
        await apiPost("/api/round/save", {
          roundId,
          tonAddress: addr,
          score,
          state: { board, tray, comboStreak, isGameOver, score }
        });
      } catch {}
    }, 1200);
  }

  
  // ===== Actions =====
  connectWalletBtn.addEventListener('click', async () => {
    if(!tonConnectUI){
      setHint("TON UI ещё не готов.");
      return;
    }
    try{
      tonConnectUI.openModal();
    } catch {
      setHint("Не удалось открыть окно подключения.");
    }
  });

  depositOpenBtn.addEventListener('click', () => {
    const addr = requireWalletOrHint();
    if(!addr) return;
    openMoneyModal("deposit");
  });

  withdrawOpenBtn.addEventListener('click', () => {
    const addr = requireWalletOrHint();
    if(!addr) return;
    openMoneyModal("withdraw");
  });

  startRoundBtn.addEventListener('click', () => {
    const addr = requireWalletOrHint();
    if(!addr) return;
    openMoneyModal("stake");
  });

  startGameBtn.addEventListener('click', () => {
    const addr = requireWalletOrHint();
    if(!addr) return;
    openMoneyModal("stake");
  });

  moneyCancelBtn.addEventListener('click', closeMoneyModal);
  moneyOverlay.addEventListener('pointerdown', (e) => {
    if(e.target === moneyOverlay) closeMoneyModal();
  });

  moneyConfirmBtn.addEventListener('click', async () => {
    const addr = requireWalletOrHint();
    if(!addr) return;

    const amt = tonStrToNanotons(moneyAmountInput.value || "0");
    if(amt <= 0n){
      setHint("Введите сумму (например 0.1).");
      return;
    }

    if(moneyMode === "deposit"){
      closeMoneyModal();
      setHint("");

      // 1) create deposit id on backend
      let dep;
      try{
        dep = await apiPost("/api/deposit/create", { tonAddress: addr, amountNano: amt.toString() });
      } catch {
        setHint("Сервер депозита недоступен.");
        return;
      }
      if(!dep || !dep.ok || !dep.depositId || !dep.houseAddress){
        setHint("Ошибка создания депозита.");
        return;
      }

      const depositId = dep.depositId;
      const houseAddress = dep.houseAddress;
      const payloadB64 = await createCommentPayloadBase64(depositId);

      // 2) send TON tx
      try{
        await tonConnectUI.sendTransaction({
          validUntil: Math.floor(Date.now()/1000) + 300,
          messages: [{
            address: houseAddress,
            amount: amt.toString(),
            ...(payloadB64 ? { payload: payloadB64 } : {})
          }]
        });
        setHint("Транзакция отправлена. Проверяю депозит…");
      } catch {
        setHint("Депозит отменён или ошибка кошелька.");
        return;
      }

      // 3) verify (poll)
      let confirmed = false;
      for(let i=0;i<12;i++){
        await new Promise(r=>setTimeout(r, 1700));
        try{
          const v = await apiPost("/api/deposit/verify", { depositId });
          if(v && v.ok && v.status === "confirmed"){ confirmed = true; break; }
        } catch {}
      }
      if(!confirmed){
        setHint("Депозит пока не подтверждён. Баланс обновится после подтверждения.");
        return;
      }

      setHint("Депозит подтверждён. Баланс обновлён.");
      await upsertUserAndLoadBalance(addr);
      return;
    }

    if(moneyMode === "withdraw"){
      closeMoneyModal();
      setHint("");

      try{
        const j = await apiPost("/api/withdraw/request", { tonAddress: addr, amountNano: amt.toString() });
        if(j && j.ok){
          setHint(`Заявка на вывод: ${j.withdrawId} (pending)`);
          await refreshInternalBalance(addr);
        } else {
          setHint(j?.error === "insufficient_balance" ? "Недостаточно баланса." : "Ошибка вывода.");
        }
      } catch {
        setHint("Сервер недоступен (withdraw).");
      }
      return;
    }

    // stake / start round
    closeMoneyModal();
    setHint("");

    // NOTE: backend currently doesn't reserve stake; we store stake locally and settle via /api/round/end.
    // Next step: add /api/round/reserve to move balance->locked.
    try{
      const rr = await apiPost("/api/round/start", { tonAddress: addr });
      if(rr && rr.ok && rr.roundId){
        roundId = rr.roundId;
        roundDepositNanotons = amt;
        roundStartedAt = nowMs();
        newGame(true);
        setHint("Раунд начат.");
        // Save initial state
        saveRound();
      } else {
        setHint("Не удалось начать раунд (сервер).");
      }
    } catch {
      setHint("Сервер недоступен (start round).");
    }
  });

    const addr = requireWalletOrHint();
    if(!addr) return;

    const amt = tonStrToNanotons(amountInput.value || "0");
    if(amt <= 0n){
      setHint("Введи сумму для вывода.");
      return;
    }

    try{
      const j = await apiPost("/api/withdraw/request", { tonAddress: addr, amountNano: amt.toString() });
      if(j && j.ok){
        setHint(`Заявка на вывод: ${j.withdrawId} (pending)`);
        await refreshInternalBalance(addr);
      } else {
        setHint(j?.error === "insufficient_balance" ? "Недостаточно баланса." : "Ошибка вывода.");
      }
    } catch {
      setHint("Сервер недоступен (withdraw).");
    }
  });

  // ===== Payout helpers (client-side for display only) =====
  function payoutMultiplierFromScore(s){
    let mult = 0;
    if(s <= 0) return 0;
    const a = Math.min(s, 10000);
    mult += Math.floor(a / 1000) * 0.1;
    if(s > 10000){
      const b = Math.min(s, 15000) - 10000;
      mult += Math.floor(b / 1000) * 0.2;
    }
    if(s > 15000){
      const c = Math.min(s, 30000) - 15000;
      mult += Math.floor(c / 1000) * 0.3;
    }
    if(s > 30000){
      const d = s - 30000;
      mult += Math.floor(d / 1000) * 0.3;
    }
    return Math.round(mult * 1000) / 1000;
  }

  function nanotonsToTonStr(n){
    const ton = Number(n) / 1e9;
    return (Math.floor(ton*1000)/1000).toFixed(3);
  }

  function tonStrToNanotons(str){
    const v = Number(String(str).replace(",", "."));
    if(!Number.isFinite(v) || v <= 0) return 0n;
    return BigInt(Math.round(v * 1e9));
  }

  // ===== Buttons / modal =====
  newGameBtn.addEventListener('click', () => {
    if(isGameOver){
      newGame(false);
      return;
    }
    openModal('confirm');
  });

  modalPrimary.addEventListener('click', () => {
    closeModal();
    newGame(false);
  });

  modalSecondary.addEventListener('click', () => {
    closeModal();
  });

  overlay.addEventListener('pointerdown', (e) => {
    if(e.target === overlay && !isGameOver) closeModal();
  });

  function newGame(resetDeposit){
    isGameOver = false;
    closeModal();
    board = Array.from({length:N}, () => Array(N).fill(null));
    tray = [randomPiece(), randomPiece(), randomPiece()];
    comboStreak = 0;
    if(resetDeposit){
      // keep deposit for active server round
    } else {
      roundDepositNanotons = 0n;
      roundStartedAt = null;
      roundId = null;
    }
    setScore(0);
    renderBoard();
    renderTray();
    saveRound();
    setHint("");
  }

  // ===== TonConnect init =====
  async function initTonConnect(){
    const TonConnectUINamespace = window.TON_CONNECT_UI || window.TonConnectUI;
    const TonConnectUIClass = TonConnectUINamespace?.TonConnectUI || TonConnectUINamespace;
    if(!TonConnectUIClass){
      tonBalanceEl.textContent = "TON недоступен";
      return;
    }

    tonConnectUI = new TonConnectUIClass({
      manifestUrl: location.origin + "/tonconnect-manifest.json",
      buttonRootId: "tonconnect-button"
    });

    try { await tonConnectUI.connector.restoreConnection(); } catch {}

    tonConnectUI.onStatusChange(async (wallet) => {
      if(wallet){
        const addr = wallet.account?.address || "";
        tonAddrEl.textContent = addr ? (addr.slice(0,6) + "…" + addr.slice(-6)) : "";
        await upsertUserAndLoadBalance(addr);
        await loadServerRoundIfAny(addr);
      } else {
        tonAddrEl.textContent = "";
        tonBalanceEl.textContent = "—";
      }
    });

    const w = tonConnectUI.wallet;
    if(w?.account?.address){
      tonAddrEl.textContent = w.account.address.slice(0,6) + "…" + w.account.address.slice(-6);
      await upsertUserAndLoadBalance(w.account.address);
      await loadServerRoundIfAny(w.account.address);
    }
  }

  // init
  buildGrid();
  initTonConnect();
  if(!loadRound()){
    tray = [randomPiece(), randomPiece(), randomPiece()];
    renderBoard();
    renderTray();
  }
})();
</script>
</body>
</html>
